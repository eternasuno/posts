---
title: "KMP 算法"
date: "2021-04-13"
tags: ["algorithm"]
---

字符串匹配是指在一长字符串（称为主串）中找出其是否包含某一个或多个字符串（称为模式串）并找出匹配的起始位置。解决字符串匹配一种直观的算法就是暴力算法：比较以主串的每一个字符为起点、长度与模式串相同的字串是否与模式串相等，这种算法的时间复杂度为 $O(mn)$ (m, n 分别为主串和模式串的长度)。显然当字符串较长时，暴力算法的耗时是不可接受的。

<!-- excerpt -->

优化暴力算法的思路是当模式串不匹配时本身就包含有足够的信息来确定下一个匹配可能的开始位置，利用这一特性可以避免比较先前匹配过的字符串，这就是 KMP 算法。

## 基本思路

下面以在 `S = "ABC ABCDAB ABCDABD"` 中匹配 `p = "ABCDABD"` 为例说明 KMP 算法的基本思路。

```
i:012345678901234567
S:ABC ABCDAB ABCDABD
P:ABCDABD
j:0123456
    P:ABCDABD
    j:0123456
```

一开始从 `i = j = 0` 开始比较 `S[i]` 和 `P[j]`，如果两者相等则令 `i += 1, j+=1` 到下一字符继续比较。比较到 `i = j = 3` 时有 `S[i] != P[j]`，说明以 `S[0]` 为起点的子字符串与匹配串不相等，此时根据暴力算法应该令 `i = 1, j = 0` 继续比较。但是此时的主串和匹配串前三个字符是相同的，都是 "ABC" ，那么显然用 `S[1]` 和 `S[2]` 为起点的子字符串不可能与匹配串相等，因此可以直接跳过 `S[1]` 和 `S[2]` 令 `i = 3, j = 0` 继续比较。而 `S[3]` 与 `P[0]` 也不相等，因此令 `i += 1, j = 0` 从下一字符开始继续比较。

```
i:012345678901234567
S:ABC ABCDAB ABCDABD
    P:ABCDABD
    j:0123456
        P:ABCDABD
        j:0123456
          P:ABCDABD
          j:0123456
```

如上所示，P 串和 S 串中的 "ABCDAB" 子串是匹配的，然而下一个字符处 `S[10] != p[6]` 并不相等，因此需要寻找新的起点重新开始比较。注意到此时已匹配的字串中 “AB” 在头尾均有出现，这就意味着可以用 S 中尾部的 “AB” 直接匹配 P 中头部的 ”AB“，从 "AB" 的后面开始比较， 即可以令 `i = 10, j = 2` 开始比较。而 `S[10]` 也不等于 `P[2]` ，此时相同的串 "AB" 中并没有和上面那样头尾一致的子字符串，因此令 `i = 10, j = 0` 从 P 串的开头开始比较。`S[10]` 与 `P[0]` 也不相等，因此令 `i += 1, j = 0` 从下一字符开始继续比较。

```
i:012345678901234567
S:ABC ABCDAB ABCDABD
           P:ABCDABD
           j:0123456
```

最后，在 `i = 11` 时找到完全匹配的字符串。

从上述过程可以发现，i 和 j 的值的改变有三种情况：

-   当前比较的字符相等时 `i += 1, j += 1`；
-   当前比较的字符在 P 串的起点且其与 S 串当前比较的字符不相等时，`i += 1, j = 0`；
-   当前比较的字符不是 P 串的起点且其与 S 串当前比较的字符不相等时，`i` 的值保持不变，而 `j` 的值需要修改，修改后的 `j` 值为 `P[0 : j]` 的前缀集合和后缀集合中最长的公共元素的长度（字符串 S 的前缀集合为 $\{S[0:i]\mid i < len(S)\}$，后缀集合为 $\{S[i:len(S)] \mid i > 0\}$）。记 `next[j]` 为 `P[0 : j]` 的前缀集合和后缀集合中最长的公共元素的长度， 则 `j` 值的变化可以表示为 `j = next[j]`。

注意到 next[0] 是没有定义的，可以令 `next[0] = -1`，这样前两种情况就可以统一为 `i += 1, j += 1`（此时 `j = next[0] = -1`）。 由此得出 KMP 算法的代码如下：

```go
func kmp(s, p string) int {
	i, j := 0, 0
	for i < len(s) {
		if j == -1 || s[i] == p[j] {
			i += 1
			j += 1
			// 匹配
			if j == len(p) {
				return i - j
			}
		} else {
			j = next[j]
		}
	}
	// 未匹配返回 -1
	return -1
}
```

## 构建 next 数组

从上面的讨论可以得出 next 数组的定义：`next[i]` 为模式串 P 的子字符串 `P[0 : i]` 的前缀集合和后缀集合中最长的公共元素的长度，且 `next[0] = -1`。

令 `j = next[i]`，根据 next 数组的定义有 `P[0 : j] == P[i - j : i]`：

-   如果 `P[j]` 与 `P[i]` 相同，那么就有 `P[0 : j + 1] == P[i - j : i + 1]`，即若 `P[i] == P[j]`，则 `next[i + 1] = j + 1`。
-   如果 `P[i] != P[j]`，这时需要找到一个新的 `j` 令 `P[0 : j] == P[i - j : i]` 成立。注意到 `P[0 : next[j]] == P[j - next[j] : j]`，而 `P[j - next[j] : j] == P[i - next[j] : i]` （`P[0 : j] == P[i - j : i]` ），则可以令 `j == next[j]` 然后再比较 `P[j]` 与 `P[i]`。
-   特别的，当 `j == -1` 时，说明 `P[0 : i]` 的前后缀集合中没有公共元素，因此不需要比较直接令 `next[i] = 0 = j + 1`。

根据上述讨论可以得到构建 next 数组的代码如下：

```go
func getNext(p string) []int {
	next := make([]int, len(p))
	next[0] = -1
	i, j := 0, -1
	for i < len(p) - 1 {
		if j == -1 || p[i] == p[j] {
			i += 1
			j += 1
			next[i] = j
		} else {
			j = next[j]
		}
	}
	return next
}
```

## 复杂度分析

从上述分析中可以看出在匹配（构建 next 数组的过程可以看作模式串的自我匹配）的过程中指示主串的游标始终在前进，前进的距离为主串的长度。因此 KMP 算法的时间复杂度为 $O(m + n)$ ，空间复杂度为 $O(n)$（m, n 分别为主串和模式串的长度）。
